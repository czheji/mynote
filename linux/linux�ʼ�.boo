<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<root version="7" DefaultSaveDir="" DefaultSaveExtension="png">
	<item content="常用命令" icon="none" branch="open" block="shrink" level="0" IsShown="true" IsBold="true" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:06:59" IsFile="false">
		<item content="基本命令和用法" icon="flag" branch="open" block="narrow" level="1" IsShown="true" IsBold="true" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 11:16:44" IsFile="false">
			<item content="使用 `&lt;命令&gt;` 执行命令，并把结果返回，等价的形式是$(&lt;命令&gt;)&#xA;  例1 使用`date +&quot;%Y-%m-%d %H:%M:%S&quot;` 获得系统当前时间，并把时间存入临时变量mydate,echo打印出结果是2011-08-15 11:10:37&#xA;  &gt;mydate=`date +&quot;%Y-%m-%d %H:%M:%S&quot;` &lt;==或写成 $(date +&quot;%Y-%m-%d %H:%M:%S&quot;)&#xA;  &gt;echo $mydate&#xA;  2011-08-15 11:10:37&#xA;  例2 使用`cat ./.bashrc`读出用户配置文件，并存入变量myrc,使用 echo &quot;$myrc&quot;打印出结果&#xA;  &gt;myrc=`cat ./.bashrc`&#xA;  &gt;echo &quot;$myrc&quot;  &lt;==myrc 被转换成字符串，否则不能用echo打印出&#xA;# .bashrc&#xA;&#xA;# User specific aliases and functions&#xA;&#xA;alias rm=&apos;rm -i&apos;&#xA;alias cp=&apos;cp -i&apos;&#xA;alias mv=&apos;mv -i&apos;&#xA;&#xA;# Source global definitions&#xA;if [ -f /etc/bashrc ]; then&#xA;        . /etc/bashrc&#xA;fi" icon="tick" branch="none" block="shrink" level="2" IsShown="true" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 11:28:23" IsFile="false"/>
			<item content="ln 命令" icon="none" branch="open" block="narrow" level="2" IsShown="true" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 12:56:57" IsFile="false">
				<item content="ln 建立链接命令（包括软连接和硬连接）&#xA;ln [option] source_file dist_file&#xA;-f 建立时，将同档案名删除.&#xA;-i 删除前进行询问.&#xA;ln -s abc cde 建立abc 的软连接&#xA;ln abc cde 建立abc的硬连接，&#xA;软连接和硬连接可以这样理解：硬连接就像一个文件有多个文件名，&#xA;软连接就是产生一个新文件，这个文件&#xA;指向另一个文件的位置，硬连接必须在同一文件系统中，而软连接可以跨文件系统.&#xA;&#xA;对于一个文件来说，有唯一的索引接点（inode）与之对应，而对于一个索引接点号，却可以有多个文件名与之对应。因此，在磁盘上的同一个文件可以通过不同的路径去访问该文件。注意在Linux下是一切皆文件的啊，文件夹、新加的硬盘 ...都可以看着文件来处理的啊。&#xA;连接有软连接和硬连接(hard link)之分的，软连接(symbolic link)又叫符号连接。符号连接相当于Windows下的快捷方式。&#xA;不可以对文件夹建立硬连接的，我们通常用的还是软连接比较多。    &#xA;&#xA;eg:&#xA;ln -s source dist        # 建立软连接&#xA;ln source dist          # 建立硬连接&#xA;&#xA;&#xA;软链接实际上只是一段文字，里面包含着它所指向的文件的名字，系统看到软链接后自动跳到对应的文件位置处进行处理；相反，硬联接为文件开设一个新的目录项，硬链接与文件原有的名字是平权的，在Linux看来它们是等价的。由于这个原因，硬链接不能连接两个不同文件系统上的文件。 " icon="none" branch="none" block="narrow" level="3" IsShown="true" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 12:57:21" IsFile="false"/>
			</item>
			<item content="find 命令" icon="none" branch="close" block="narrow" level="2" IsShown="true" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 13:51:47" IsFile="false">
				<item content="1. 想查看当前文件夹及子文件夹里有没有文件名为“abc”的文件&#xA; &#xA;# find . -name abc&#xA; &#xA;. ：表示当前目录&#xA; &#xA;-name：表示要根据名称查找&#xA; &#xA;2. 想查看当前文件夹及子文件夹里有没有”xyz”目录&#xA; &#xA;# find . -type d -name xyz&#xA; &#xA;-type：表示设定类型，d表示文件夹类型，可以替换为f(普通文件)、l(链接文件)&#xA; &#xA;3. 想找出当前文件夹及子文件夹里所有后缀是”.txt”的文件&#xA; &#xA;# find . -name “*.txt”&#xA; &#xA;4. 想查找当前目录及其子文件夹中“roc”用户自己的文件有哪些&#xA; &#xA;# find . -user roc&#xA; &#xA;-user：用于设定所属用户的名称，此处可替换为-group，即所属用户组的名称&#xA; &#xA;5. 想查找当前文件夹及子文件夹里权限设定为755的所有文件&#xA; &#xA;&#xA;&#xA;# find . -perm 755&#xA; &#xA;-perm：用于设定权限&#xA; &#xA;6. 想查找当前文件夹及子文件夹里的同时含有b字符和3字符的文件：用到正则表达式技术&#xA; &#xA;# find . -regex ‘.*b.*3′&#xA; &#xA;-regex：表示使用正则表达式进行匹配。请注意，此命令会和“全路径”进行匹配，也就是说前面要加.*，因为输出结果中会有“./”符号。&#xA; &#xA;7. 如果想全部输出用find命令查找出的”*.abc”文件的内容&#xA; &#xA;# find . -type f -name “*.abc” -exec cat {} \;&#xA; &#xA;-exec 表示由find找到的匹配项会作为“-exec后面设定的命令”的参数&#xA; &#xA;可以使用-ok代替-exec，这样对每个匹配项进行操作，都会要求用户确认（y为是，n为否）&#xA; &#xA;命令最后的{} \; 别忘了写，其中{}代表用find查找到的结果中的每一个查找项。&#xA; &#xA;8. 查找当前目录下在5分钟内被访问过的文件 &#xA;&#xA;# find . -amin -5&#xA; &#xA;访问过用amin，修改过用mmin，文件状态改变过用cmin&#xA; &#xA;精确到分钟的用amin,mmin,cmin，精确到天的用atime,mtime,ctime&#xA; &#xA;在5分钟之内的用-5，在5分钟以上的用＋5&#xA; &#xA;9. 想查找当前目录及子目录下文件大小大于10M的所有文件&#xA; &#xA;# find . -size +10000000c&#xA; &#xA;-size：表示文件大小，＋表示大于某个数，－表示小于某个数。c表示单位是字节，你可以将c换成k,M,G。&#xA; &#xA;10. 上述所有的find命令都是查找当前目录及其子目录。如果不想深入到子目录中，而是只查找当前一层目录，则可以：&#xA; &#xA;# find . -maxdepth 1 -name “*.c”&#xA; &#xA;over~" icon="none" branch="none" block="shrink" level="3" IsShown="false" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 13:51:56" IsFile="false"/>
			</item>
		</item>
	</item>
	<item content="Shell脚本" icon="none" branch="none" block="shrink" level="0" IsShown="true" IsBold="true" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:07:20" IsFile="false"/>
	<item content="启动与设置" icon="none" branch="open" block="narrow" level="0" IsShown="true" IsBold="true" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:07:49" IsFile="false">
		<item content="Linux启动过程" icon="tick" branch="close" block="narrow" level="1" IsShown="true" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:14:11" IsFile="false">
			<item content="本文以RedHat9.0和i386平台为例，剖析了从用户打开电源直到屏幕出现命令行提示符的整个Linux启动过程。并且介绍了启动中涉及到的各种文件。 &#xA;　　阅读Linux源代码，无疑是深入学习Linux的最好方法。在本文对Linux启动过程的介绍中，我们也尝试从源代码的视角来更深入的剖析Linux的启动过程，所以其中也简单涉及到部分相关的Linux源代码，Linux启动这部分的源码主要使用的是C语言，也涉及到了少量的汇编。而启动过程中也执行了大量的shell(主要是bash shell)所写脚本。为了方便读者阅读，笔者将整个Linux启动过程分成以下几个部分逐一介绍，大家可以参考下图：&#xA;&#xA;　　当用户打开PC的电源，BIOS开机自检，按BIOS中设置的启动设备(通常是硬盘)启动，接着启动设备上安装的引导程序lilo或grub开始引导Linux，Linux首先进行内核的引导，接下来执行init程序，init程序调用了rc.sysinit和rc等程序，rc.sysinit和rc当完成系统初始化和运行服务的任务后，返回init；init启动了mingetty后，打开了终端供用户登录系统，用户登录成功后进入了Shell，这样就完成了从开机到登录的整个启动过程。&#xA;&#xA;&#xA;&#xA;    下面就将逐一介绍其中几个关键的部分： &#xA;&#xA;&#xA;　　第一部分：内核的引导(核内引导)&#xA;&#xA;　　Red Hat9.0可以使用lilo或grub等引导程序开始引导Linux系统，当引导程序成功完成引导任务后，Linux从它们手中接管了CPU的控制权，然后CPU就开始执行Linux的核心映象代码，开始了Linux启动过程。这里使用了几个汇编程序来引导Linux，这一步泛及到Linux源代码树中的“arch/i386/boot”下的这几个文件：bootsect.S、setup.S、video.S等。&#xA;&#xA;　　其中bootsect.S是生成引导扇区的汇编源码，它完成加载动作后直接跳转到setup.S的程序入口。setup.S的主要功能就是将系统参数（包括内存、磁盘等，由BIOS返回）拷贝到特别内存中，以便以后这些参数被保护模式下的代码来读取。此外，setup.S还将video.S中的代码包含进来，检测和设置显示器和显示模式。最后，setup.S将系统转换到保护模式，并跳转到 0x100000。&#xA;&#xA;　　那么0x100000这个内存地址中存放的是什么代码？而这些代码又是从何而来的呢？&#xA;&#xA;　　0x100000这个内存地址存放的是解压后的内核，因为Red Hat提供的内核包含了众多驱动和功能而显得比较大，所以在内核编译中使用了“makebzImage”方式，从而生成压缩过的内核，在RedHat中内核常常被命名为vmlinuz，在Linux的最初引导过程中，是通过&quot;arch/i386/boot/compressed/&quot;中的head.S利用misc.c中定义的decompress_kernel()函数，将内核vmlinuz解压到0x100000的。&#xA;&#xA;　　当CPU跳到0x100000时，将执行&quot;arch/i386/kernel/head.S&quot;中的startup_32，它也是vmlinux的入口，然后就跳转到start_kernel()中去了。start_kernel()是&quot;init/main.c&quot;中的定义的函数，start_kernel()中调用了一系列初始化函数，以完成kernel本身的设置。start_kernel()函数中，做了大量的工作来建立基本的Linux核心环境。如果顺利执行完start_kernel()，则基本的Linux核心环境已经建立起来了。&#xA;&#xA;　　在start_kernel()的最后，通过调用init()函数，系统创建第一个核心线程，启动了init过程。而核心线程init()主要是来进行一些外设初始化的工作的，包括调用do_basic_setup()完成外设及其驱动程序的加载和初始化。并完成文件系统初始化和root文件系统的安装。&#xA;&#xA;　　当do_basic_setup()函数返回init()，init()又打开了/dev/console设备，重定向三个标准的输入输出文件stdin、stdout和stderr到控制台，最后，搜索文件系统中的init程序（或者由init=命令行参数指定的程序），并使用 execve()系统调用加载执行init程序。到此init()函数结束，内核的引导部分也到此结束了，&#xA;&#xA;    第二部分：运行init &#xA;&#xA;&#xA;　　init的进程号是1，从这一点就能看出，init进程是系统所有进程的起点，Linux在完成核内引导以后，就开始运行init程序，。init程序需要读取配置文件/etc/inittab。inittab是一个不可执行的文本文件，它有若干行指令所组成。在Redhat系统中，inittab的内容如下所示(以“###&quot;开始的中注释为笔者增加的)：&#xA;&#xA;　　#&#xA;　　# inittab       This file describes how the INIT process should set up&#xA;　　#               the system in a certain run-level.&#xA;　　#&#xA;　　# Author:       Miquel van Smoorenburg,&#xA;&#xA;　　#               Modified for RHS Linux by Marc Ewing and Donnie Barnes&#xA;　　#&#xA;&#xA;　　# Default runlevel. The runlevels used by RHS are:&#xA;　　#   0 - halt (Do NOT set initdefault to this)&#xA;　　#   1 - Single user mode&#xA;　　#   2 - Multiuser, without NFS (The same as 3, if you do not havenetworking)&#xA;　　#   3 - Full multiuser mode&#xA;　　#   4 - unused&#xA;　　#   5 - X11&#xA;　　#   6 - reboot (Do NOT set initdefault to this)&#xA;　　#&#xA;　　###表示当前缺省运行级别为5(initdefault)；&#xA;　　id:5:initdefault:&#xA;&#xA;　　###启动时自动执行/etc/rc.d/rc.sysinit脚本(sysinit)&#xA;　　# System initialization.&#xA;　　si::sysinit:/etc/rc.d/rc.sysinit&#xA;&#xA;　　l0:0:wait:/etc/rc.d/rc 0&#xA;　　l1:1:wait:/etc/rc.d/rc 1&#xA;　　l2:2:wait:/etc/rc.d/rc 2&#xA;　　l3:3:wait:/etc/rc.d/rc 3&#xA;　　l4:4:wait:/etc/rc.d/rc 4&#xA;　　###当运行级别为5时，以5为参数运行/etc/rc.d/rc脚本，init将等待其返回(wait)&#xA;　　l5:5:wait:/etc/rc.d/rc 5&#xA;　　l6:6:wait:/etc/rc.d/rc 6&#xA;&#xA;　　###在启动过程中允许按CTRL-ALT-DELETE重启系统&#xA;　　# Trap CTRL-ALT-DELETE&#xA;　　ca::ctrlaltdel:/sbin/shutdown -t3 -r now&#xA;&#xA;　　# When our UPS tells us power has failed, assume we have a few minutes&#xA;　　# of power left.  Schedule a shutdown for 2 minutes from now.&#xA;　　# This does, of course, assume you have powerd installed and your&#xA;　　# UPS connected and working correctly.&#xA;　　pf::powerfail:/sbin/shutdown -f -h +2 &quot;Power Failure; System Shutting Down&quot;&#xA;&#xA;　　# If power was restored before the shutdown kicked in, cancel it.&#xA;　　pr:12345:powerokwait:/sbin/shutdown -c &quot;Power Restored; Shutdown Cancelled&quot;&#xA;&#xA;　　###在2、3、4、5级别上以ttyX为参数执行/sbin/mingetty程序，打开ttyX终端用于用户登录，&#xA;　　###如果进程退出则再次运行mingetty程序(respawn)&#xA;　　# Run gettys in standard runlevels&#xA;　　1:2345:respawn:/sbin/mingetty tty1&#xA;　　2:2345:respawn:/sbin/mingetty tty2&#xA;　　3:2345:respawn:/sbin/mingetty tty3&#xA;　　4:2345:respawn:/sbin/mingetty tty4&#xA;　　5:2345:respawn:/sbin/mingetty tty5&#xA;　　6:2345:respawn:/sbin/mingetty tty6&#xA;&#xA;　　###在5级别上运行xdm程序，提供xdm图形方式登录界面，并在退出时重新执行(respawn)&#xA;　　# Run xdm in runlevel 5&#xA;　　x:5:respawn:/etc/X11/prefdm -nodaemon&#xA;&#xA;以上面的inittab文件为例，来说明一下inittab的格式。其中以#开始的行是注释行，除了注释行之外，每一行都有以下格式： &#xA;　　id:runlevel:action:process&#xA;&#xA;　　对上面各项的详细解释如下：&#xA;&#xA;　　1. id&#xA;&#xA;　　id是指入口标识符，它是一个字符串，对于getty或mingetty等其他login程序项，要求id与tty的编号相同，否则getty程序将不能正常工作。&#xA;&#xA;　　2. runlevel&#xA;&#xA;　　runlevel是init所处于的运行级别的标识，一般使用0－6以及S或s。0、1、6运行级别被系统保留：其中0作为shutdown动作，1作为重启至单用户模式，6为重启；S和s意义相同，表示单用户模式，且无需inittab文件，因此也不在inittab中出现，实际上，进入单用户模式时，init直接在控制台（/dev/console）上运行/sbin/sulogin。在一般的系统实现中，都使用了2、3、4、5几个级别，在Redhat系统中，2表示无NFS支持的多用户模式，3表示完全多用户模式（也是最常用的级别），4保留给用户自定义，5表示XDM图形登录方式。7－9级别也是可以使用的，传统的Unix系统没有定义这几个级别。runlevel可以是并列的多个值，以匹配多个运行级别，对大多数action来说，仅当runlevel与当前运行级别匹配成功才会执行。&#xA;&#xA;　　3. action&#xA;&#xA;　　action是描述其后的process的运行方式的。action可取的值包括：initdefault、sysinit、boot、bootwait等：&#xA;&#xA;　　initdefault是一个特殊的action值，用于标识缺省的启动级别；当init由核心激活以后，它将读取inittab中的initdefault项，取得其中的runlevel，并作为当前的运行级别。如果没有inittab文件，或者其中没有initdefault项，init将在控制台上请求输入runlevel。&#xA;&#xA;　　sysinit、boot、bootwait等action将在系统启动时无条件运行，而忽略其中的runlevel。&#xA;&#xA;　　其余的action（不含initdefault）都与某个runlevel相关。各个action的定义在inittab的man手册中有详细的描述。&#xA;&#xA;　　4. process&#xA;&#xA;　　process为具体的执行程序。程序后面可以带参数。&#xA;&#xA;　　第三部分：系统初始化&#xA;&#xA;　　在init的配置文件中有这么一行：&#xA;&#xA;　　si::sysinit:/etc/rc.d/rc.sysinit&#xA;&#xA;　　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。&#xA;&#xA;　　rc.sysinit约有850多行，但是每个单一的功能还是比较简单，而且带有注释，建议有兴趣的用户可以自行阅读自己机器上的该文件，以了解系统初始化所详细情况。由于此文件较长，所以不在本文中列出来，也不做具体的介绍。&#xA;&#xA;　　当rc.sysinit程序执行完毕后，将返回init继续下一步。&#xA;&#xA;&#xA;第四部分：启动对应运行级别的守护进程 &#xA;&#xA;&#xA;　　在rc.sysinit执行后，将返回init继续其它的动作，通常接下来会执行到/etc/rc.d/rc程序。以运行级别3为例，init将执行配置文件inittab中的以下这行：&#xA;&#xA;　　l5:5:wait:/etc/rc.d/rc 5&#xA;&#xA;　　这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些链接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。&#xA;&#xA;　　/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的链接文件，对于以以S开头的启动脚本，将以start参数来运行。而如果发现存在相应的脚本也存在K打头的链接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。&#xA;&#xA;　　至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的&quot;System Services&quot;来自行设定。常见的守护进程有：&#xA;&#xA;　　amd：自动安装NFS守护进程&#xA;　　apmd:高级电源管理守护进程&#xA;　　arpwatch：记录日志并构建一个在LAN接口上看到的以太网地址和IP地址对数据库&#xA;　　autofs：自动安装管理进程automount，与NFS相关，依赖于NIS&#xA;　　crond：Linux下的计划任务的守护进程&#xA;　　named：DNS服务器&#xA;　　netfs：安装NFS、Samba和NetWare网络文件系统&#xA;　　network：激活已配置网络接口的脚本程序&#xA;　　nfs：打开NFS服务&#xA;　　portmap：RPC portmap管理器，它管理基于RPC服务的连接&#xA;　　sendmail：邮件服务器sendmail&#xA;　　smb：Samba文件共享/打印服务&#xA;　　syslog：一个让系统引导时起动syslog和klogd系统日志守候进程的脚本&#xA;　　xfs：X Window字型服务器，为本地和远程X服务器提供字型集&#xA;　　Xinetd：支持多种网络服务的核心守护进程，可以管理wuftp、sshd、telnet等服务&#xA;&#xA;　　这些守护进程也启动完成了，rc程序也就执行完了，然后又将返回init继续下一步。&#xA;&#xA;    第五部分：建立终端 &#xA;&#xA;&#xA;　　rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统。通过按Alt+Fn(n对应1-6)可以在这6个终端中切换。在inittab中的以下6行就是定义了6个终端：&#xA;&#xA;　　1:2345:respawn:/sbin/mingetty tty1&#xA;　　2:2345:respawn:/sbin/mingetty tty2&#xA;　　3:2345:respawn:/sbin/mingetty tty3&#xA;　　4:2345:respawn:/sbin/mingetty tty4&#xA;　　5:2345:respawn:/sbin/mingetty tty5&#xA;　　6:2345:respawn:/sbin/mingetty tty6&#xA;&#xA;　　从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。&#xA;&#xA;　　第六部分：登录系统，启动完成&#xA;&#xA;　　对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入KDE、Gnome等窗口管理器。而本文主要讲的还是文本方式登录的情况：&#xA;&#xA;　　当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。&#xA;&#xA;　　Linux的账号验证程序是login，login会接收mingetty传来的用户名作为用户名参数。然后login会对用户名进行分析：如果用户名不是root，且存在/etc/nologin文件，login将输出nologin文件的内容，然后退出。这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许root用户登录，如果不存在这个文件，则root可以在任何终端上登录。/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。&#xA;&#xA;　　在分析完用户名后，login将搜索/etc/passwd以及/etc/shadow来验证密码以及设置账户的其它信息，比如：主目录是什么、使用何种shell。如果没有指定主目录，将默认为根目录；如果没有指定shell，将默认为/bin/bash。&#xA;&#xA;　　login程序成功后，会向对应的终端在输出最近一次登录的信息(在/var/log/lastlog中有记录)，并检查用户是否有新邮件(在/usr/spool/mail/的对应用户名目录下)。然后开始设置各种环境变量：对于bash来说，系统首先寻找/etc/profile脚本文件，并执行它；然后如果用户的主目录中存在.bash_profile文件，就执行它，在这些文件中又可能调用了其它配置文件，所有的配置文件执行后后，各种环境变量也设好了，这时会出现大家熟悉的命令行提示符，到此整个启动过程就结束了。&#xA;&#xA;　　希望通过上面对Linux启动过程的剖析能帮助那些想深入学习Linux用户建立一个相关Linux启动过程的清晰概念，进而可以进一步研究Linux接下来是如何工作的。" icon="none" branch="none" block="narrow" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:14:15" IsFile="false"/>
			<item content=".\linux启动过程.png" icon="none" branch="none" block="wide" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:14:28" IsImage="true" IsFile="true"/>
		</item>
		<item content="linux下的用户环境设置" icon="flag" branch="close" block="narrow" level="1" IsShown="true" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:40:17" IsFile="false">
			<item content="用户环境的设置分为以下五个文件：" icon="none" branch="none" block="narrow" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="fa7d0000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:43:30" IsFile="false"/>
			<item content="/etc/profile：此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置." icon="star" branch="none" block="narrow" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="0000ff00" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:43:22" IsFile="false"/>
			<item content="/etc/bashrc：为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取." icon="star" branch="none" block="narrow" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="0000ff00" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:43:26" IsFile="false"/>
			<item content="~/.bash_profile:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件." icon="star" branch="none" block="narrow" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="0000ff00" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:44:04" IsFile="false"/>
			<item content="~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取." icon="star" branch="none" block="narrow" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="0000ff00" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:44:27" IsFile="false"/>
			<item content="~/.bash_logout:当每次退出系统(退出bash shell)时,执行该文件. " icon="star" branch="none" block="narrow" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="0000ff00" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:44:54" IsFile="false"/>
			<item content="另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是&quot;父子&quot;关系.&#xA;~/.bash_profile 是交互式、login 方式进入 bash 运行的&#xA;~/.bashrc 是交互式 non-login 方式进入 bash 运行的&#xA;通常二者设置大致相同，所以通常前者会调用后者。 " icon="none" branch="none" block="narrow" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:46:16" IsFile="false"/>
		</item>
		<item content="Linux2.6 内核的 Initrd 机制解析" icon="none" branch="close" block="narrow" level="1" IsShown="true" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 13:10:45" IsFile="false">
			<item content="引用网址 http://www.ibm.com/developerworks/cn/linux/l-k26initrd/" icon="none" branch="none" block="narrow" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 13:11:01" IsFile="false"/>
			<item content="简介&#xA;Linux 的 initrd 技术是一个非常普遍使用的机制，linux2.6 内核的 initrd 的文件格式由原来的文件系统镜像文件转变成了 cpio 格式，变化不仅反映在文件格式上， linux 内核对这两种格式的 initrd 的处理有着截然的不同。本文首先介绍了什么是 initrd 技术，然后分别介绍了 Linux2.4 内核和 2.6 内核的 initrd 的处理流程。最后通过对 Linux2.6 内核的 initrd 处理部分代码的分析，使读者可以对 initrd 技术有一个全面的认识。为了更好的阅读本文，要求读者对 Linux 的 VFS 以及 initrd 有一个初步的了解。" icon="none" branch="none" block="narrow" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 13:11:15" IsFile="false"/>
			<item content="1．什么是 Initrd&#xA;&#xA;initrd 的英文含义是 boot loader initialized RAM disk，就是由 boot loader 初始化的内存盘。在 linux内核启动前， boot loader 会将存储介质中的 initrd 文件加载到内存，内核启动时会在访问真正的根文件系统前先访问该内存中的 initrd 文件系统。在 boot loader 配置了 initrd 的情况下，内核启动被分成了两个阶段，第一阶段先执行 initrd 文件系统中的&quot;某个文件&quot;，完成加载驱动模块等任务，第二阶段才会执行真正的根文件系统中的 /sbin/init 进程。这里提到的&quot;某个文件&quot;，Linux2.6 内核会同以前版本内核的不同，所以这里暂时使用了&quot;某个文件&quot;这个称呼，后面会详细讲到。第一阶段启动的目的是为第二阶段的启动扫清一切障爱，最主要的是加载根文件系统存储介质的驱动模块。我们知道根文件系统可以存储在包括IDE、SCSI、USB在内的多种介质上，如果将这些设备的驱动都编译进内核，可以想象内核会多么庞大、臃肿。&#xA;&#xA;Initrd 的用途主要有以下四种：&#xA;&#xA;1. linux 发行版的必备部件&#xA;&#xA;linux 发行版必须适应各种不同的硬件架构，将所有的驱动编译进内核是不现实的，initrd 技术是解决该问题的关键技术。Linux 发行版在内核中只编译了基本的硬件驱动，在安装过程中通过检测系统硬件，生成包含安装系统硬件驱动的 initrd，无非是一种即可行又灵活的解决方案。&#xA;&#xA;2. livecd 的必备部件&#xA;&#xA;同 linux 发行版相比，livecd 可能会面对更加复杂的硬件环境，所以也必须使用 initrd。&#xA;&#xA;3. 制作 Linux usb 启动盘必须使用 initrd&#xA;&#xA;usb 设备是启动比较慢的设备，从驱动加载到设备真正可用大概需要几秒钟时间。如果将 usb 驱动编译进内核，内核通常不能成功访问 usb 设备中的文件系统。因为在内核访问 usb 设备时， usb 设备通常没有初始化完毕。所以常规的做法是，在 initrd 中加载 usb 驱动，然后休眠几秒中，等待 usb设备初始化完毕后再挂载 usb 设备中的文件系统。&#xA;&#xA;4. 在 linuxrc 脚本中可以很方便地启用个性化 bootsplash。&#xA;&#xA;&#xA;--------------------------------------------------------------------------------&#xA;回页首&#xA;2．Linux2.4内核对 Initrd 的处理流程&#xA;&#xA;为了使读者清晰的了解Linux2.6内核initrd机制的变化，在重点介绍Linux2.6内核initrd之前，先对linux2.4内核的initrd进行一个简单的介绍。Linux2.4内核的initrd的格式是文件系统镜像文件，本文将其称为image-initrd，以区别后面介绍的linux2.6内核的cpio格式的initrd。 linux2.4内核对initrd的处理流程如下：&#xA;&#xA;1. boot loader把内核以及/dev/initrd的内容加载到内存，/dev/initrd是由boot loader初始化的设备，存储着initrd。&#xA;&#xA;2. 在内核初始化过程中，内核把 /dev/initrd 设备的内容解压缩并拷贝到 /dev/ram0 设备上。&#xA;&#xA;3. 内核以可读写的方式把 /dev/ram0 设备挂载为原始的根文件系统。&#xA;&#xA;4. 如果 /dev/ram0 被指定为真正的根文件系统，那么内核跳至最后一步正常启动。&#xA;&#xA;5. 执行 initrd 上的 /linuxrc 文件，linuxrc 通常是一个脚本文件，负责加载内核访问根文件系统必须的驱动， 以及加载根文件系统。&#xA;&#xA;6. /linuxrc 执行完毕，真正的根文件系统被挂载。&#xA;&#xA;7. 如果真正的根文件系统存在 /initrd 目录，那么 /dev/ram0 将从 / 移动到 /initrd。否则如果 /initrd 目录不存在， /dev/ram0 将被卸载。&#xA;&#xA;8. 在真正的根文件系统上进行正常启动过程 ，执行 /sbin/init。 linux2.4 内核的 initrd 的执行是作为内核启动的一个中间阶段，也就是说 initrd 的 /linuxrc 执行以后，内核会继续执行初始化代码，我们后面会看到这是 linux2.4 内核同 2.6 内核的 initrd 处理流程的一个显著区别。&#xA;&#xA;&#xA;--------------------------------------------------------------------------------&#xA;回页首&#xA;3．Linux2.6 内核对 Initrd 的处理流程&#xA;&#xA;linux2.6 内核支持两种格式的 initrd，一种是前面第 3 部分介绍的 linux2.4 内核那种传统格式的文件系统镜像－image-initrd，它的制作方法同 Linux2.4 内核的 initrd 一样，其核心文件就是 /linuxrc。另外一种格式的 initrd 是 cpio 格式的，这种格式的 initrd 从 linux2.5 起开始引入，使用 cpio 工具生成，其核心文件不再是 /linuxrc，而是 /init，本文将这种 initrd 称为 cpio-initrd。尽管 linux2.6 内核对 cpio-initrd和 image-initrd 这两种格式的 initrd 均支持，但对其处理流程有着显著的区别，下面分别介绍 linux2.6 内核对这两种 initrd 的处理流程。&#xA;&#xA;cpio-initrd 的处理流程&#xA;&#xA;1． boot loader 把内核以及 initrd 文件加载到内存的特定位置。&#xA;&#xA;2． 内核判断initrd的文件格式，如果是cpio格式。&#xA;&#xA;3． 将initrd的内容释放到rootfs中。&#xA;&#xA;4． 执行initrd中的/init文件，执行到这一点，内核的工作全部结束，完全交给/init文件处理。&#xA;&#xA;image-initrd的处理流程&#xA;&#xA;1． boot loader把内核以及initrd文件加载到内存的特定位置。&#xA;&#xA;2． 内核判断initrd的文件格式，如果不是cpio格式，将其作为image-initrd处理。&#xA;&#xA;3． 内核将initrd的内容保存在rootfs下的/initrd.image文件中。&#xA;&#xA;4． 内核将/initrd.image的内容读入/dev/ram0设备中，也就是读入了一个内存盘中。&#xA;&#xA;5． 接着内核以可读写的方式把/dev/ram0设备挂载为原始的根文件系统。&#xA;&#xA;6． .如果/dev/ram0被指定为真正的根文件系统，那么内核跳至最后一步正常启动。&#xA;&#xA;7． 执行initrd上的/linuxrc文件，linuxrc通常是一个脚本文件，负责加载内核访问根文件系统必须的驱动， 以及加载根文件系统。&#xA;&#xA;8． /linuxrc执行完毕，常规根文件系统被挂载&#xA;&#xA;9． 如果常规根文件系统存在/initrd目录，那么/dev/ram0将从/移动到/initrd。否则如果/initrd目录不存在， /dev/ram0将被卸载。&#xA;&#xA;10． 在常规根文件系统上进行正常启动过程 ，执行/sbin/init。&#xA;&#xA;通过上面的流程介绍可知，Linux2.6内核对image-initrd的处理流程同linux2.4内核相比并没有显著的变化， cpio-initrd的处理流程相比于image-initrd的处理流程却有很大的区别，流程非常简单，在后面的源代码分析中，读者更能体会到处理的简捷。&#xA;&#xA;4．cpio-initrd同image-initrd的区别与优势&#xA;&#xA;没有找到正式的关于cpio-initrd同image-initrd对比的文献，根据笔者的使用体验以及内核代码的分析，总结出如下三方面的区别，这些区别也正是cpio-initrd的优势所在：&#xA;&#xA;cpio-initrd的制作方法更加简单&#xA;&#xA;cpio-initrd的制作非常简单，通过两个命令就可以完成整个制作过程&#xA;&#xA;&#xA;#假设当前目录位于准备好的initrd文件系统的根目录下&#xA;bash# find . | cpio -c -o &gt; ../initrd.img&#xA;bash# gzip ../initrd.img&#xA; &#xA;&#xA;&#xA;而传统initrd的制作过程比较繁琐，需要如下六个步骤&#xA;&#xA;&#xA;#假设当前目录位于准备好的initrd文件系统的根目录下&#xA;bash# dd if=/dev/zero of=../initrd.img bs=512k count=5&#xA;bash# mkfs.ext2 -F -m0 ../initrd.img&#xA;bash# mount -t ext2 -o loop ../initrd.img  /mnt&#xA;bash# cp -r  * /mnt&#xA;bash# umount /mnt&#xA;bash# gzip -9 ../initrd.img&#xA; &#xA;&#xA;&#xA;本文不对上面命令的含义作细节的解释，因为本文主要介绍的是linux内核对initrd的处理，对上面命令不理解的读者可以参考相关文档。&#xA;&#xA;cpio-initrd的内核处理流程更加简化&#xA;&#xA;通过上面initrd处理流程的介绍，cpio-initrd的处理流程显得格外简单，通过对比可知cpio-initrd的处理流程在如下两个方面得到了简化：&#xA;&#xA;1． cpio-initrd并没有使用额外的ramdisk,而是将其内容输入到rootfs中，其实rootfs本身也是一个基于内存的文件系统。这样就省掉了ramdisk的挂载、卸载等步骤。&#xA;&#xA;2． cpio-initrd启动完/init进程，内核的任务就结束了，剩下的工作完全交给/init处理；而对于image-initrd，内核在执行完/linuxrc进程后，还要进行一些收尾工作，并且要负责执行真正的根文件系统的/sbin/init。通过图1可以更加清晰的看出处理流程的区别：&#xA;&#xA;&#xA;图1内核对cpio-initrd和image-initrd处理流程示意图&#xA; &#xA;&#xA;cpio-initrd的职责更加重要&#xA;&#xA;如图1所示，cpio-initrd不再象image-initrd那样作为linux内核启动的一个中间步骤，而是作为内核启动的终点，内核将控制权交给cpio-initrd的/init文件后，内核的任务就结束了，所以在/init文件中，我们可以做更多的工作，而不比担心同内核后续处理的衔接问题。当然目前linux发行版的cpio-initrd的/init文件的内容还没有本质的改变，但是相信initrd职责的增加一定是一个趋势。&#xA;&#xA;&#xA;--------------------------------------------------------------------------------&#xA;回页首&#xA;5．linux2.6内核initrd处理的源代码分析&#xA;&#xA;上面简要介绍了Linux2.4内核和2.6内核的initrd的处理流程，为了使读者对于Linux2.6内核的initrd的处理有一个更加深入的认识，下面将对Linuxe2.6内核初始化部分同initrd密切相关的代码给予一个比较细致的分析，为了讲述方便，进一步明确几个代码分析中使用的概念：&#xA;&#xA;rootfs: 一个基于内存的文件系统，是linux在初始化时加载的第一个文件系统,关于它的进一步介绍可以参考文献[4]。&#xA;&#xA;initramfs: initramfs同本文的主题关系不是很大，但是代码中涉及到了initramfs，为了更好的理解代码，这里对其进行简单的介绍。Initramfs是在 kernel 2.5中引入的技术，实际上它的含义就是：在内核镜像中附加一个cpio包，这个cpio包中包含了一个小型的文件系统，当内核启动时，内核将这个cpio包解开，并且将其中包含的文件系统释放到rootfs中，内核中的一部分初始化代码会放到这个文件系统中，作为用户层进程来执行。这样带来的明显的好处是精简了内核的初始化代码，而且使得内核的初始化过程更容易定制。Linux 2.6.12内核的 initramfs还没有什么实质性的东西，一个包含完整功能的initramfs的实现可能还需要一个缓慢的过程。对于initramfs的进一步了解可以参考文献[1][2][3]。&#xA;&#xA;cpio-initrd: 前面已经定义过，指linux2.6内核使用的cpio格式的initrd。&#xA;&#xA;image-initrd: 前面已经定义过，专指传统的文件镜像格式的initrd。&#xA;&#xA;realfs: 用户最终使用的真正的文件系统。&#xA;&#xA;内核的初始化代码位于 init/main.c 中的 static int init(void * unused)函数中。同initrd的处理相关部分函数调用层次如下图，笔者按照这个层次对每一个函数都给予了比较详细的分析，为了更好的说明，下面列出的代码中删除了同本文主题不相关的部分：&#xA;&#xA;&#xA;图2 initrd相关代码的调用层次关系图&#xA; &#xA;&#xA;init函数是内核所有初始化代码的入口，代码如下，其中只保留了同initrd相关部分的代码。&#xA;&#xA;&#xA;static int init(void * unused){&#xA;[1]	populate_rootfs();&#xA;	&#xA;[2]	if (sys_access((const char __user *) &quot;/init&quot;, 0) == 0)&#xA;		execute_command = &quot;/init&quot;;&#xA;	else&#xA;		prepare_namespace();&#xA;[3]	if (sys_open((const char __user *) &quot;/dev/console&quot;, O_RDWR, 0) &lt; 0)&#xA;		printk(KERN_WARNING &quot;Warning: unable to open an initial console.\n&quot;);&#xA;	(void) sys_dup(0);&#xA;	(void) sys_dup(0);&#xA;[4]	if (execute_command)&#xA;		run_init_process(execute_command);&#xA;	run_init_process(&quot;/sbin/init&quot;);&#xA;	run_init_process(&quot;/etc/init&quot;);&#xA;	run_init_process(&quot;/bin/init&quot;);&#xA;	run_init_process(&quot;/bin/sh&quot;);&#xA;	panic(&quot;No init found.  Try passing init= option to kernel.&quot;);&#xA;}&#xA; &#xA;&#xA;&#xA;代码[1]：populate_rootfs函数负责加载initramfs和cpio-initrd，对于populate_rootfs函数的细节后面会讲到。&#xA;&#xA;代码[2]：如果rootfs的根目录下中包含/init进程，则赋予execute_command,在init函数的末尾会被执行。否则执行prepare_namespace函数，initrd是在该函数中被加载的。&#xA;&#xA;代码[3]：将控制台设置为标准输入，后续的两个sys_dup(0),则复制标准输入为标准输出和标准错误输出。&#xA;&#xA;代码[4]：如果rootfs中存在init进程，就将后续的处理工作交给该init进程。其实这段代码的含义是如果加载了cpio-initrd则交给cpio-initrd中的/init处理，否则会执行realfs中的init。读者可能会问：如果加载了cpio-initrd, 那么realfs中的init进程不是没有机会运行了吗？确实，如果加载了cpio-initrd,那么内核就不负责执行realfs的init进程了，而是将这个执行任务交给了cpio-initrd的init进程。解开fedora core4的initrd文件，会发现根目录的下的init文件是一个脚本，在该脚本的最后一行有这样一段代码： &#xA;&#xA;&#xA;………..&#xA;switchroot --movedev /sysroot&#xA; &#xA;&#xA;&#xA;就是switchroot语句负责加载realfs,以及执行realfs的init进程。&#xA;&#xA;对cpio-initrd的处理&#xA;&#xA;对cpio-initrd的处理位于populate_rootfs函数中。&#xA;&#xA;&#xA;void __init populate_rootfs(void){&#xA;[1]  char *err = unpack_to_rootfs(__initramfs_start,&#xA;			 __initramfs_end - __initramfs_start, 0);&#xA;[2]	if (initrd_start) {&#xA;[3]		err = unpack_to_rootfs((char *)initrd_start,&#xA;			initrd_end - initrd_start, 1);&#xA;	&#xA;[4]		if (!err) {&#xA;			printk(&quot; it is\n&quot;);&#xA;			unpack_to_rootfs((char *)initrd_start,&#xA;				initrd_end - initrd_start, 0);&#xA;			free_initrd_mem(initrd_start, initrd_end);&#xA;			return;&#xA;		}&#xA;[5]		fd = sys_open(&quot;/initrd.image&quot;, O_WRONLY|O_CREAT, 700);&#xA;		if (fd &gt;= 0) {&#xA;			sys_write(fd, (char *)initrd_start,&#xA;					initrd_end - initrd_start);&#xA;			sys_close(fd);&#xA;			free_initrd_mem(initrd_start, initrd_end);&#xA;		}&#xA;}&#xA; &#xA;&#xA;&#xA;代码[1]：加载initramfs， initramfs位于地址__initramfs_start处，是内核在编译过程中生成的，initramfs的是作为内核的一部分而存在的，不是 boot loader加载的。前面提到了现在initramfs没有任何实质内容。&#xA;&#xA;代码[2]：判断是否加载了initrd。无论哪种格式的initrd，都会被boot loader加载到地址initrd_start处。&#xA;&#xA;代码[3]：判断加载的是不是cpio-initrd。实际上 unpack_to_rootfs有两个功能一个是释放cpio包，另一个就是判断是不是cpio包， 这是通过最后一个参数来区分的， 0：释放 1：查看。&#xA;&#xA;代码[4]：如果是cpio-initrd则将其内容释放出来到rootfs中。&#xA;&#xA;代码[5]：如果不是cpio-initrd,则认为是一个image-initrd，将其内容保存到/initrd.image中。在后面的image-initrd的处理代码中会读取/initrd.image。&#xA;&#xA;对image-initrd的处理在prepare_namespace函数里，包含了对image-initrd进行处理的代码，相关代码如下：&#xA;&#xA;&#xA;void __init prepare_namespace(void){&#xA;[1]	if (initrd_load())&#xA;		goto out;&#xA;out:&#xA;		umount_devfs(&quot;/dev&quot;);&#xA;[2]		sys_mount(&quot;.&quot;, &quot;/&quot;, NULL, MS_MOVE, NULL);&#xA;		sys_chroot(&quot;.&quot;);&#xA;		security_sb_post_mountroot();&#xA;		mount_devfs_fs ();&#xA;}&#xA; &#xA;&#xA;&#xA;代码[1]：执行initrd_load函数，将initrd载入，如果载入成功的话initrd_load函数会将realfs的根设置为当前目录。&#xA;&#xA;代码[2]：将当前目录即realfs的根mount为Linux VFS的根。initrd_load函数执行完后，将真正的文件系统的根设置为当前目录。&#xA;&#xA;initrd_load函数负责载入image-initrd，代码如下：&#xA;&#xA;&#xA;int __init initrd_load(void)&#xA;{&#xA;[1]	if (mount_initrd) {&#xA;		create_dev(&quot;/dev/ram&quot;, Root_RAM0, NULL);&#xA;[2]		if (rd_load_image(&quot;/initrd.image&quot;) &amp;&amp; ROOT_DEV != Root_RAM0) {&#xA;			sys_unlink(&quot;/initrd.image&quot;);&#xA;			handle_initrd();&#xA;			return 1;&#xA;		}&#xA;	}&#xA;	sys_unlink(&quot;/initrd.image&quot;);&#xA;	return 0;&#xA;}&#xA; &#xA;&#xA;&#xA;代码[1]：如果加载initrd则建立一个ram0设备 /dev/ram。&#xA;&#xA;代码[2]：/initrd.image文件保存的就是image-initrd，rd_load_image函数执行具体的加载操作，将image-nitrd的文件内容释放到ram0里。判断ROOT_DEV!=Root_RAM0的含义是，如果你在grub或者lilo里配置了 root=/dev/ram0 ,则实际上真正的根设备就是initrd了，所以就不把它作为initrd处理 ，而是作为realfs处理。&#xA;&#xA;handle_initrd()函数负责对initrd进行具体的处理，代码如下：&#xA;&#xA;&#xA;	static void __init handle_initrd(void){&#xA;[1]	real_root_dev = new_encode_dev(ROOT_DEV);&#xA;[2]	create_dev(&quot;/dev/root.old&quot;, Root_RAM0, NULL);&#xA;	mount_block_root(&quot;/dev/root.old&quot;, root_mountflags &amp; ~MS_RDONLY);&#xA;[3]	sys_mkdir(&quot;/old&quot;, 0700);&#xA;	root_fd = sys_open(&quot;/&quot;, 0, 0);&#xA;	old_fd = sys_open(&quot;/old&quot;, 0, 0);&#xA;	/* move initrd over / and chdir/chroot in initrd root */&#xA;[4]	sys_chdir(&quot;/root&quot;);&#xA;	sys_mount(&quot;.&quot;, &quot;/&quot;, NULL, MS_MOVE, NULL);&#xA;	sys_chroot(&quot;.&quot;);&#xA;	mount_devfs_fs ();&#xA;[5]	pid = kernel_thread(do_linuxrc, &quot;/linuxrc&quot;, SIGCHLD);&#xA;	if (pid &gt; 0) {&#xA;		while (pid != sys_wait4(-1, &amp;i, 0, NULL))&#xA;			yield();&#xA;	}&#xA;	/* move initrd to rootfs&apos; /old */&#xA;	sys_fchdir(old_fd);&#xA;	sys_mount(&quot;/&quot;, &quot;.&quot;, NULL, MS_MOVE, NULL);&#xA;	/* switch root and cwd back to / of rootfs */&#xA;[6]	sys_fchdir(root_fd);&#xA;	sys_chroot(&quot;.&quot;);&#xA;	sys_close(old_fd);&#xA;	sys_close(root_fd);&#xA;	umount_devfs(&quot;/old/dev&quot;);&#xA;[7]	if (new_decode_dev(real_root_dev) == Root_RAM0) {&#xA;		sys_chdir(&quot;/old&quot;);&#xA;		return;&#xA;	}&#xA;[8]	ROOT_DEV = new_decode_dev(real_root_dev);&#xA;	mount_root();&#xA;[9]	printk(KERN_NOTICE &quot;Trying to move old root to /initrd ... &quot;);&#xA;	error = sys_mount(&quot;/old&quot;, &quot;/root/initrd&quot;, NULL, MS_MOVE, NULL);&#xA;	if (!error)&#xA;		printk(&quot;okay\n&quot;);&#xA;	else {&#xA;		int fd = sys_open(&quot;/dev/root.old&quot;, O_RDWR, 0);&#xA;		printk(&quot;failed\n&quot;);&#xA;		printk(KERN_NOTICE &quot;Unmounting old root\n&quot;);&#xA;		sys_umount(&quot;/old&quot;, MNT_DETACH);&#xA;		printk(KERN_NOTICE &quot;Trying to free ramdisk memory ... &quot;);&#xA;		if (fd &lt; 0) {&#xA;			error = fd;&#xA;		} else {&#xA;			error = sys_ioctl(fd, BLKFLSBUF, 0);&#xA;			sys_close(fd);&#xA;		}&#xA;		printk(!error ? &quot;okay\n&quot; : &quot;failed\n&quot;);&#xA;	}&#xA;	 &#xA;&#xA;&#xA;handle_initrd函数的主要功能是执行initrd的linuxrc文件，并且将realfs的根目录设置为当前目录。&#xA;&#xA;代码[1]：real_root_dev，是一个全局变量保存的是realfs的设备号。&#xA;&#xA;代码[2]：调用mount_block_root函数将initrd文件系统挂载到了VFS的/root下。&#xA;&#xA;代码[3]：提取rootfs的根的文件描述符并将其保存到root_fd。它的作用就是为了在chroot到initrd的文件系统，处理完initrd之后要，还能够返回rootfs。返回的代码参考代码[7]。&#xA;&#xA;代码[4]：chroot进入initrd的文件系统。前面initrd已挂载到了rootfs的/root目录。&#xA;&#xA;代码[5]：执行initrd的linuxrc文件，等待其结束。&#xA;&#xA;代码[6]：initrd处理完之后，重新chroot进入rootfs。&#xA;&#xA;代码[7]：如果real_root_dev在 linuxrc中重新设成Root_RAM0，则initrd就是最终的realfs了，改变当前目录到initrd中，不作后续处理直接返回。&#xA;&#xA;代码[8]：在linuxrc执行完后，realfs设备已经确定，调用mount_root函数将realfs挂载到root_fs的 /root目录下，并将当前目录设置为/root。&#xA;&#xA;代码[9]：后面的代码主要是做一些收尾的工作，将initrd的内存盘释放。&#xA;&#xA;到此代码分析完毕。&#xA;&#xA;&#xA;--------------------------------------------------------------------------------&#xA;回页首&#xA;6．结束语&#xA;&#xA;通过本文前半部分对cpio-initrd和imag-initrd的阐述与对比以及后半部分的代码分析，我相信读者对Linux 2.6内核的initrd技术有了一个较为全面的了解。在本文的最后，给出两点最重要的结论：&#xA;&#xA;1． 尽管Linux2.6既支持cpio-initrd，也支持image-initrd，但是cpio-initrd有着更大的优势，在使用中我们应该优先考虑使用cpio格式的initrd。&#xA;&#xA;2． cpio-initrd相对于image-initrd承担了更多的初始化责任，这种变化也可以看作是内核代码的用户层化的一种体现，我们在其它的诸如FUSE等项目中也看到了将内核功能扩展到用户层实现的尝试。精简内核代码，将部分功能移植到用户层必然是linux内核发展的一个趋势。&#xA;&#xA;&#xA;--------------------------------------------------------------------------------&#xA;回页首&#xA;参考资料&#xA;&#xA;从下面三篇文章中，可以获得更多的关于initramfs的知识：&#xA;&#xA;[1]http://tree.celinuxforum.org/pubwiki/moin.cgi/EarlyUserSpace &#xA;&#xA;[2]http://lwn.net/Articles/14776/ &#xA;&#xA;[3]http://www.ussg.iu.edu/hypermail/linux/kernel/0211.0/0341.html &#xA;&#xA;从下面这篇文章中读者可以了解到关于linux VSF、rootfs的相关知识：&#xA;&#xA;[4] http://www.ibm.com/developerworks/cn/linux/l-vfs/ &#xA;&#xA;下面是一些initrd的参考资料：&#xA;&#xA;[5] http://www.die.net/doc/linux/man/man4/initrd.4.html " icon="none" branch="none" block="shrink" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 13:11:36" IsFile="false"/>
		</item>
	</item>
	<item content="发行版" icon="none" branch="open" block="shrink" level="0" IsShown="true" IsBold="true" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:09:31" IsFile="false">
		<item content="Debian" icon="none" branch="open" block="narrow" level="1" IsShown="true" IsBold="true" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:16:22" IsFile="false">
			<item content="http://www.debian.org/" icon="tick" branch="none" block="narrow" level="2" IsShown="true" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:16:47" IsFile="false"/>
			<item content="在Debian基本系统下安装无线网卡驱动（6.0.2），并使用WPA2" icon="tick" branch="close" block="narrow" level="2" IsShown="true" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:23:49" IsFile="false">
				<item content="如果仅使用WEP加密的无线网络，在Debian 6.0.2 的基本系统中已经包括，不过想要使用WPA2加密，就必须用wpa_supplicant，安装wpa_supplicant的过程如下：&#xA;1 使用 dpkg -i 命令安装无线网卡驱动和wpa_supplicant的依赖包：&#xA;  dpkg -i firmware-iwlwifi_0.33_all &lt;==无线网卡驱动&#xA;  dpkg -i wireless-tools_30~pre9-5_amd64.deb&#xA;  dpkg -i libpcsclite1_1.5.5-4_amd64.deb&#xA;  dpkg -i libnl1_1.1-6_amd64.deb&#xA;  dpkg -i libdbus-1-3_1.2.24-4+squeeze1_amd64.deb&#xA;2 使用 dpkg -i 安装wpa_supplicant&#xA;  dpkg -i wpasupplicant_0.6.10-2.1_amd64.deb&#xA;3 配置/etc/network/interfaces&#xA;  auto wlan0 &lt;==根据无线网卡的名称，修改wlan0，下同&#xA;  iface wlan0 inet dhcp &lt;==如果使用dhcp分配&#xA;  #-------如果是静态ip，按照如下配置&#xA;  #iface eth0 inet static&#xA;  #address 192.168.1.2  &lt;==本机ip地址&#xA;  #netmask 255.255.255.0  &lt;==子网掩码&#xA;  #gateway 192.168.1.1  &lt;==网关&#xA;  #dns-nameservers 192.168.1.1  &lt;==dns，或在/etc/resolv.conf 设置DNS服务器 nameserver &#xA;  pre-up ip link set wlan0 up &#xA;  pre-up iwconfig wlan0 essid your-ssid &lt;==无线网络的SSID&#xA;  wpa-ssid your-ssid &lt;==无线网络的SSID&#xA;  wpa-psk your-password  &lt;==无线网络的密码&#xA;4 重新启动无线网卡&#xA;  ifdown wlan0&#xA;  ifup wlan0&#xA;另：查看网卡流量的命令&#xA;  watch -n 1 &quot;/sbin/ifconfig eth0 | grep bytes&quot;" icon="none" branch="none" block="narrow" level="3" IsShown="false" IsBold="false" ShowBranch="false" TextColor="00800000" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:53:16" IsFile="false"/>
				<item content=".\无线网卡\wpasupplicant_0.6.10-2.1_amd64.deb" icon="none" branch="none" block="narrow" level="3" IsShown="false" IsBold="false" ShowBranch="false" TextColor="0000ff00" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:53:22" IsImage="false" IsFile="true"/>
				<item content=".\无线网卡\libdbus-1-3_1.2.24-4+squeeze1_amd64.deb" icon="none" branch="none" block="narrow" level="3" IsShown="false" IsBold="false" ShowBranch="false" TextColor="0000ff00" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:22:46" IsImage="false" IsFile="true"/>
				<item content=".\无线网卡\libnl1_1.1-6_amd64.deb" icon="none" branch="none" block="narrow" level="3" IsShown="false" IsBold="false" ShowBranch="false" TextColor="0000ff00" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:22:38" IsImage="false" IsFile="true"/>
				<item content=".\无线网卡\libpcsclite1_1.5.5-4_amd64.deb" icon="none" branch="none" block="narrow" level="3" IsShown="false" IsBold="false" ShowBranch="false" TextColor="0000ff00" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:22:35" IsImage="false" IsFile="true"/>
				<item content=".\无线网卡\wireless-tools_30~pre9-5_amd64.deb" icon="none" branch="none" block="narrow" level="3" IsShown="false" IsBold="false" ShowBranch="false" TextColor="0000ff00" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:22:32" IsImage="false" IsFile="true"/>
				<item content=".\无线网卡\firmware-iwlwifi_0.33_all.deb" icon="none" branch="none" block="narrow" level="3" IsShown="false" IsBold="false" ShowBranch="false" TextColor="0000ff00" BkgrdColor="ffffff00" ModifyTime="2011-08-15 10:20:43" IsImage="false" IsFile="true"/>
			</item>
		</item>
		<item content="Arch" icon="none" branch="open" block="narrow" level="1" IsShown="true" IsBold="true" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 13:53:53" IsFile="false">
			<item content="官方网站 http://www.archlinux.org/" icon="none" branch="none" block="narrow" level="2" IsShown="true" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 15:07:40" IsFile="false"/>
			<item content="" icon="none" branch="none" block="narrow" level="2" IsShown="true" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" IsFile="false"/>
		</item>
	</item>
	<item content="应用程序" icon="none" branch="open" block="narrow" level="0" IsShown="true" IsBold="true" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 12:10:18" IsFile="false">
		<item content="动态dns客户端inadyn" icon="none" branch="close" block="narrow" level="1" IsShown="true" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 12:11:15" IsFile="false">
			<item content="官方网站 http://www.inatech.eu/inadyn/" icon="none" branch="none" block="shrink" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 12:11:27" IsFile="false"/>
			<item content="在Debian下安装" icon="none" branch="close" block="narrow" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 12:11:45" IsFile="false">
				<item content="apt-get install inadyn" icon="none" branch="none" block="narrow" level="3" IsShown="false" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 12:11:57" IsFile="false"/>
			</item>
			<item content="配置文件 /etc/inadyn.conf" icon="none" branch="close" block="narrow" level="2" IsShown="false" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 12:12:26" IsFile="false">
				<item content="配置&#xA;Inadyn 配置文件中的选项和命令行一样。在 **NIX 系统中，默认的配置文件是： /etc/inadyn.conf&#xA;配置文件的位置可以用 --input_file 选项给出。&#xA;配置文件的格式是 :&#xA;- &apos;#&apos; 是注释. &#xA;- 长选项 (那些以 &apos;--&apos; 开头的) 可以省略 &apos;--&apos; &#xA;例子:&#xA;1.&#xA;#一些inadyn配置文件的提示&#xA;--username test --password test --update_period 60000 --alias test.homeip.net --alias my.second.domain&#xA;2.&#xA;--username test #用户名&#xA;--password test #密码&#xA;update_period 60000  #更新周期，这里没有使用 &apos;--&apos; 作为开头 &#xA;alias test.homeip.net &#xA;&#xA;日志输出&#xA;当IP更新后，Inadyn会打印一些消息。每当它进行域名检查时，如果IP不需要更新，它默认的会打印一个&apos;.&apos;，所以默认的，你会在日志文件中看到很多的点。(only if verbose level is greater than 0).&#xA;当连接down时，inadyn可能会显示一些错误，但是在稍后连接再次up，总会跟着&apos;OK&apos;消息。&#xA;&#xA;对于 freedns.afraid.org 的特别提示：&#xA;这个网站会使用  username, password的hash值(base64 encoded)代替用户名的密码&#xA;This saves some computing resources apparently. The hash cannot be computed by inadyn because it involve the database index of your username in freedns database which is not known.&#xA;The simplest solution seems to be the copy-paste action from the graburl batch file offered on their website.&#xA;Example: The batch file looks like this:&#xA;graburl http://freedns.afraid.org/dynamic/update.php?YUGIUGSEIUFGOUIHEOIFEOIHJFEIO=&#xA;The user has to copy and paste the hash value after the &apos;?&apos; until the end of line.&#xA;The hash will be used as additional param in --alias option. (see typical usage above)&#xA;&#xA;命令行选项&#xA;这些会自动显示出来，如果inadyn检查到一个错误的选项或者是使用了 --help 选项&#xA;参数:&#xA;&#xA;&apos;--help&apos;: 帮助&#xA;&apos;-h&apos;: 帮助&#xA;&#xA;&apos;--username&apos;: 你的账号名/ 账号名哈希值(hash)&#xA;&apos;-u&apos;: 你的账号名/ 账号名哈希值(hash)&#xA;&#xA;&apos;--password&apos;: 你的密码，可选&#xA;&apos;-p&apos;: 你的密码&#xA;&#xA;&apos;--alias&apos;: 主机域名（alias host name），这个选项可以出现多次 。(多个域名使用相同的IP)&#xA;&apos;-a&apos;: 主机域名（alias host name），这个选项可以出现多次 。&#xA;&#xA;&apos;--input_file&apos;: 包含inadyn命令行选项的文件 (adds to those already present in the cmd line)。默认的配置文件是 &apos;/etc/inadyn.conf&apos;，默认配置仅在inadyn不使用任何命令行选项是有效。&#xA;&#xA;&apos;--ip_server_name[:port] url&apos;: 用于检测主机实际IP地址的url，默认是checkip.dyndns.org:80 /. &#xA;&#xA;&apos;--dyndns_server_name&apos;: [[:port]] &#xA;The server that receives the update DNS request.&#xA;If no proxy is wanted, then it is enough to set the dyndns system. The default servers will be taken.&#xA;&#xA;&apos;--dyndns_server_url&apos; &#xA;full URL relative to DynDNS server root. &#xA;&apos;--dyndns_system&apos;: [NAME] - optional DYNDNS service type. SHOULD be one of the following:&#xA;-For dyndns.org DNS system: dyndns@dyndns.org OR statdns@dyndns.org OR custom@dyndns.org.&#xA;-For freedns.afraid.org DNS system: default@freedns.afraid.org .&#xA;-For the servcie ofered by zoneedit.com: default@zoneedit.com. &#xA;- For no-ip.com : default@no-ip.com&#xA;-For generic DNS system: custom@http_svr_basic_auth&#xA;DEFAULT value is intended for default service at dyndns.org: dyndns@dyndns.org&#xA;&#xA;&apos;--proxy_server&apos;: [NAME[:port]] - 代理服务器的名称和端口，默认是无。&#xA;&apos;--update_period&apos;: IP检测的周期，单位是ms，默认为1分钟，最大是10天。&#xA;&apos;--update_period_sec&apos;: IP检测的周期，单位是s. 默认为1分钟，最大是10天。&#xA;&apos;--forced_update_period&apos;: IP强制更新的时间，即使检测到IP并未更变，单位是s。&#xA;&apos;--log_file&apos;: 日志文件的路径&#xA;&apos;--background&apos;: 在后台运行，（如果指定的话）输出日志到syslog或日志文件&#xA;&apos;--verbose&apos;: 设置日志级别（dbg leve）， 0 到 5&#xA;&apos;--iterations&apos;: 设置更新DNS的次数，默认是0，表示无限次。&#xA;&apos;--syslog&apos;: syslog的设置. (例如 /var/log/messages). 仅在 **NIX 系统下起作用。&#xA;&apos;--change_persona uid[:gid]&apos;: 使用给定的用户ID和组ID运行inadyn，这可以使inadyn不在root权限下执行，只在 **NIX 系统中起作用。 " icon="none" branch="none" block="narrow" level="3" IsShown="false" IsBold="false" ShowBranch="false" TextColor="00000000" BkgrdColor="ffffff00" ModifyTime="2011-08-18 12:50:40" IsFile="false"/>
			</item>
		</item>
	</item>
</root>
